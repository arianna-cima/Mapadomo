# ==================================================
# DESCRIPTION OF THE DATA PROCESSING 
# ==================================================
#
# This script constructs a balanced panel of dwelling stock at the LAU level,
# disaggregated by dwelling type (all, house, flat) and year. It combines two
# data sources: municipality-level dwelling stock data for 2003–2007 (already
# split by dwelling type) and census-based dwelling counts for 2000, 2011, and
# 2021. After harmonising variable names and restricting both datasets to a
# common set of columns, observations are safely collapsed by LAU code, year,
# and dwelling type to avoid duplication.
#
# The two sources are then merged and expanded into a full panel covering all
# LAU codes, dwelling types, and years between 2000 and 2021, explicitly
# including years with missing observations. For each LAU–type combination,
# categorical identifiers (indicator and NUTS codes) are filled using a robust
# multi-pass forward- and backward-fill procedure, ensuring that identifiers
# are available even in years with no original data.
#
# Numerical dwelling stock values are subsequently linearly interpolated over
# time within each LAU–type series, without overwriting observed values.
# Finally, diagnostic time-series plots are generated by LAU code, separately
# for each dwelling type, and the resulting cleaned and interpolated panel
# dataset is saved to disk.
#
# ==================================================
# --------------------------------------------------
# 1. Load municipality stock data (already all/house/flat)
# --------------------------------------------------
df_muni <- fread(file.path(output_path, "EE_stock_flathouse_2003_2007.csv"))
df_muni <- df_muni[indicator == "dwelling"]

setnames(
  df_muni,
  c("NUTS 3 CODE 2016","NUTS 3 CODE 2021","laucode"),
  c("nuts2016","nuts2021","laucode")
)

# --------------------------------------------------
# 2. Load census dwelling data (2000 / 2011 / 2021)
# --------------------------------------------------
DT_merged <- fread(file.path(output_path, "EE_dwelling_2000_11_21.csv"))
DT_merged[, indicator := "dwelling"]

setnames(
  DT_merged,
  c("NUTS 3 CODE 2016","NUTS 3 CODE 2021","LAU CODE"),
  c("nuts2016","nuts2021","laucode")
)

common_cols <- c("municipality","year","indicator","type","value","nuts2021","nuts2016","laucode")
df_muni   <- df_muni[, ..common_cols]
DT_merged <- DT_merged[, ..common_cols]

stopifnot(identical(colnames(df_muni), colnames(DT_merged)))

# --------------------------------------------------
# 3. Collapse safely (laucode × year × type)
# --------------------------------------------------
df_muni   <- df_muni[,   .(value = sum(value, na.rm = TRUE)),
                     by = .(laucode, year, type, indicator, nuts2021, nuts2016)]

DT_merged <- DT_merged[, .(value = sum(value, na.rm = TRUE)),
                       by = .(laucode, year, type, indicator, nuts2021, nuts2016)]

# --------------------------------------------------
# 4. Combine real data sources
# --------------------------------------------------
DT_all <- rbindlist(list(df_muni, DT_merged), use.names = TRUE)
DT_all <- unique(DT_all, by = c("laucode","year","type"))
DT_all[, municipality := NULL]
setorder(DT_all, laucode, type, year)

# --------------------------------------------------
# 5. Build FULL panel: laucode × year × type
# --------------------------------------------------
missing_years <- c(2001, 2002, 2008:2020)

DT_panel <- DT_all[
  CJ(
    laucode = unique(laucode),
    type    = unique(type),
    year    = unique(c(year, missing_years)),
    unique  = TRUE
  ),
  on = .(laucode, type, year)
]

DT_panel <- DT_panel[
  DT_all,
  on = .(laucode, type, year),
  `:=`(
    indicator = fcoalesce(i.indicator, indicator),
    nuts2021  = fcoalesce(i.nuts2021, nuts2021),
    nuts2016  = fcoalesce(i.nuts2016, nuts2016),
    value     = i.value
  )
]

DT_all <- DT_panel
rm(DT_panel, missing_years)
setorder(DT_all, laucode, type, year)

# --------------------------------------------------
# 6. FILL IDENTIFIERS — robust multi-pass (THIS FIXES 2001)
# --------------------------------------------------
setorder(DT_all, laucode, type, year)

for (cc in c("indicator","nuts2016","nuts2021")) {
  
  DT_all[, (cc) := {
    x <- get(cc)
    
    # forward fill UNTIL convergence
    repeat {
      x_old <- x
      x[is.na(x)] <- shift(x, 1L, type = "lag")[is.na(x)]
      if (identical(x, x_old)) break
    }
    
    # backward fill UNTIL convergence
    repeat {
      x_old <- x
      x[is.na(x)] <- shift(x, 1L, type = "lead")[is.na(x)]
      if (identical(x, x_old)) break
    }
    
    x
  }, by = .(laucode, type)]
}

# --------------------------------------------------
# 7. Linear interpolation (SAFE: laucode × type)
# --------------------------------------------------
DT_all[, value := {
  y <- year
  v <- value
  idx <- !is.na(v)
  
  if (sum(idx) < 2) v else {
    v_int <- approx(x = y[idx], y = v[idx], xout = y, rule = 1)$y
    fifelse(is.na(v), v_int, v)
  }
}, by = .(laucode, type)]




# --------------------------------------------------
# 10. Plot time series by LAU CODE, separately by type
# --------------------------------------------------
out_dir <- file.path(out_check, "dwelling")
#dir.create(out_dir, recursive = TRUE, showWarnings = FALSE)

DT_all[, year := as.integer(year)]
setorder(DT_all, laucode, type, year)

cluster_size <- 20
lau_list <- sort(unique(DT_all$laucode))
clusters <- split(lau_list, ceiling(seq_along(lau_list) / cluster_size))

types_list <- sort(unique(DT_all$type))

for (tt in types_list) {
  
  DT_t <- DT_all[type == tt]
  
  for (i in seq_along(clusters)) {
    
    lau_subset <- clusters[[i]]
    
    p <- ggplot(
      DT_t[laucode %in% lau_subset],
      aes(x = year, y = value, group = laucode)
    ) +
      geom_line(color = "steelblue") +
      geom_point(size = 0.8) +
      facet_wrap(~ laucode, scales = "free_y") +
      coord_cartesian(ylim = c(0, NA)) +
      theme_minimal() +
      labs(
        title = paste("Dwelling stock time series –", tt, "– cluster", i),
        x = "Year",
        y = "Value"
      )
    
    ggsave(
      filename = file.path(
        out_dir,
        paste0("dwelling_timeseries_", tt, "_cluster_", i, ".png")
      ),
      plot = p,
      width = 14,
      height = 10,
      dpi = 300
    )
  }
}




setDT(DT_all)

## --------------------------------------------------
## Helper: aggregate from NUTS-3 to higher NUTS levels
## --------------------------------------------------

aggregate_from_nuts3 <- function(DT, substr_len) {
  
  DT_agg <- DT[
    ,
    .(
      value = sum(value, na.rm = TRUE)
    ),
    by = .(
      nuts_code = substr(nuts2016, 1, substr_len),
      type,
      year, 
      indicator
    )
  ]
  
  DT_agg[
    ,
    `:=`(
     laucode = nuts_code,
      lau_name = nuts_code,
      nuts2016 = nuts_code,
      nuts2021= nuts_code
    )
  ]
  
  DT_agg[, nuts_code := NULL]
  setcolorder(DT_agg, names(DT_all))
  DT_agg
}

## --------------------------------------------------
## Build NUTS levels
## --------------------------------------------------

# NUTS-3 (direct aggregation)
DT_nuts3 <- aggregate_from_nuts3(DT_all, substr_len = 5)

# NUTS-2 (EE00*)
DT_nuts2 <- aggregate_from_nuts3(DT_all, substr_len = 4)

# NUTS-1 (EE0)
DT_nuts1 <- aggregate_from_nuts3(DT_all, substr_len = 3)

# NUTS-0 (EE)
DT_nuts0 <- aggregate_from_nuts3(DT_all, substr_len = 2)

## --------------------------------------------------
## Append everything
## --------------------------------------------------

DT_all_extended <- rbindlist(
  list(
    DT_all,     # LAU
    DT_nuts3,
    DT_nuts2,
    DT_nuts1,
    DT_nuts0
  ),
  use.names = TRUE,
  fill = TRUE
)


DT_all_extended[
  ,
  level := fifelse(
    # LAU: numeric codes (do NOT start with EE)
    !grepl("^EE", as.character(`laucode`)), "laucode",
    fifelse(
      # NUTS 3: EE007
      grepl("^EE", `laucode`) & nchar(`laucode`) == 5, "nuts3",
      fifelse(
        # NUTS 2: EE00
        grepl("^EE", `laucode`) & nchar(`laucode`) == 4, "nuts2",
        fifelse(
          # NUTS 1: EE0
          grepl("^EE", `laucode`) & nchar(`laucode`) == 3, "nuts1",
          # NUTS 0: EE
          "nuts0"
        )
      )
    )
  )
]
## (Optional) make it an ordered factor
DT_all_extended[
  ,
  level := factor(level, levels = c("laucode", "nuts3", "nuts2", "nuts1", "nuts0"))
]

## --------------------------------------------------
## Save clean interpolated panel
## --------------------------------------------------

# Drop columns
DT_all_extended[,c("lau_name", "nuts2016", "nuts2021") := NULL]

# Rename LAU CODE to nuts
setnames(DT_all_extended, "laucode", "nuts")

# Add indicator
DT_all_extended[, indicator := "dwellings"]

# Melt to long format
DT_long <- melt(
  DT_all_extended,
  id.vars = c("nuts", "year", "type", "indicator","level"),
  measure.vars = "value",
  value.name = "value"
)
DT_long[,c("variable") := NULL]


write.csv(
  DT_long,
  file = file.path(output_path, "EE_dwelling_timeseries_clean.csv"),
  row.names = FALSE
)

