View(summary_wide)
# Cast each variable
total_price_wide <- dcast(summary_dt, NUTS_code + lau ~ type,
value.var = "total_price_m2",
fun.aggregate = sum, na.rm = TRUE)
setnames(total_price_wide, c("flat", "house"), c("total_flat", "total_house"))
View(total_price_wide)
avg_price_wide <- dcast(summary_dt, NUTS_code + lau ~ type,
value.var = "avg_price_m2",
fun.aggregate = mean, na.rm = TRUE)
setnames(avg_price_wide, c("flat", "house"), c("avg_flat", "avg_house"))
View(avg_price_wide)
n_ads_wide <- dcast(summary_dt, NUTS_code + lau ~ type,
value.var = "n_ads",
fun.aggregate = sum, na.rm = TRUE)
setnames(n_ads_wide, c("flat", "house"), c("n_flat", "n_house"))
# Merge all three
summary_wide <- Reduce(function(x, y) merge(x, y, by = c("NUTS_code", "lau")),
list(total_price_wide, avg_price_wide, n_ads_wide))
View(summary_wide)
# Replace NaN with NA (because mean() handles NA more naturally)
summary_wide[is.nan(avg_flat), avg_flat := NA]
# Replace NaN with NA (because mean() handles NA more naturally)
setDT(summary_wide)
summary_wide[is.nan(avg_flat), avg_flat := NA]
# Compute the mean avg_flat for each NUTS3, ignoring missing values
summary_wide[, avg_flat := ifelse(
is.na(avg_flat),
mean(avg_flat, na.rm = TRUE),
avg_flat
), by = NUTS_code]
View(summary_wide)
summary_wide$share_house <- summary_wide$avg_house / summary_wide$avg_flat
# View results
head(summary_wide)
setDT(merged_prices)
setDT(summary_wide)
# Keep only nuts3 and share_house info
shares <- summary_wide[, .(nuts3 = NUTS_code, share_house, lau)]
# ================================
# STEP 2: MERGE SHARES INTO HOUSE DATA
# ================================
# Add the house/flat ratio to each row of merged_prices
merged_prices <- merge(merged_prices, shares, by.x = "Municipality.code", by.y = "lau", all.x = TRUE)
# ================================
# STEP 3: GENERATE FLAT ROWS
# ================================
# Copy house rows, switch type to "flat",
# and scale price using share_house ratio:
#   flat_price = house_price / share_house
# This ensures consistency with the ratio definition.
# ================================
flats <- copy(merged_prices)[type.of.building == "house"]
flats[, type.of.building := "flat"]
flats[, price := price / share_house]
# ================================
# STEP 4: APPEND HOUSE + FLAT
# ================================
merged_prices_all <- rbind(merged_prices, flats, use.names = TRUE)
# Rename nuts3.x to nuts3
names(merged_prices_all)[names(merged_prices_all) == "nuts3.x"] <- "nuts3"
# Remove nuts3.y
merged_prices_all$nuts3.y <- NULL
# Keep only relevant variables
merged_prices_all <- merged_prices_all[, .(nuts3, Municipality.code, year, type.of.building, price)]
# Inspect result
head(merged_prices_all)
# Round the price column
merged_prices_all[, price := round(price)]
# Write to CSV
fwrite(merged_prices_all, file = paste0(output_path, "/SE_prices.csv"))
# ================================
# STEP 4: download average price by squaremeter
# ================================
avg_floor <- read.csv(file.path(output_path, "SE_m2_mean.csv"), stringsAsFactors = FALSE)
# Check column names
colnames(merged_prices_all)
colnames(avg_floor)
avg_floor<-data.table(avg_floor)
# If avg_floor is a data.table
# Rename column in avg_floor to match merged_prices_all
setnames(avg_floor, old = "LAU_CODE", new = "Municipality.code")
# Make sure the join columns are the same type
merged_prices_all[, Municipality.code := as.character(Municipality.code)]
avg_floor[, Municipality.code := as.character(Municipality.code)]
# Merge by year and Municipality.code
merged_data <- merge(
merged_prices_all,
avg_floor,
by = c("year", "Municipality.code", "type.of.building"),
all.x = TRUE  # left join
)
# Remove rows where avg_floor_m2 is NA
merged_data <- merged_data[!is.na(avg_floor_m2)]
# Generate price per m2
merged_data[, price_m2 := price / avg_floor_m2]
# Save to CSV in the usual output folder
# Using fwrite (fast, from data.table)
write.csv(
merged_data,
file = file.path(output_path, "SE_price_m2.csv"),
row.names = FALSE
)
View(merged_data)
# ================================
# LOAD AND PREPARE HPI DATA
# ================================
# Load the OECD HPI CSV
df <- read.csv(file.path(source_prices_path, "OECD_HPI_2025-10-01.csv"), stringsAsFactors = FALSE)
# Create 'nuts' column: uppercase and remove 'M' (both lower and uppercase)
df$nuts <- gsub("M", "", toupper(df$code))
# Apply specific mappings for certain codes
df$nuts[df$nuts == "SE001"] <- "SE110"
df$nuts[df$nuts == "SE002"] <- "SE231"
df$nuts[df$nuts == "SE003"] <- "SE224"
# Ensure df is a data.table
df <- as.data.table(df)
# Convert 'time' to Date, then extract year
df[, year := year(dmy(time))]  # dmy() converts "01/01/1986" to Date, year() extracts the year
# Keep only relevant columns
hpi_df <- df[, .(nuts, year, index)]
# Extract the 2024 index for each NUTS region (to use as base)
hpi_2024 <- hpi_df[year == 2024, .(nuts, index_2024 = index)]
# Merge 2024 index with full HPI to compute base-2024 index
hpi_df <- merge(hpi_df, hpi_2024, by = "nuts", all.x = TRUE)
# Compute HPI with base 2024 = 100
hpi_df[, index_base2024 := index / index_2024 * 100]
# Keep only necessary columns
hpi_df <- hpi_df[, .(nuts, year, index_base2024)]
# Create 'nuts3' column: if nuts has 5 characters → nuts3 = nuts, else NA
hpi_df[, nuts3 := ifelse(nchar(nuts) == 5, nuts, NA_character_)]
# Rename 'nuts' to 'nuts2' for consistency
setnames(hpi_df, "nuts", "nuts2")
# Quick check
head(hpi_df)
# ================================
# LOAD AND PREPARE MUNICIPALITY DATA
# ================================
# Load municipality Excel file
muni_df <- read_excel(file.path(source_prices_path, "average_price_2024_municipality.xlsx"))
muni_df <- as.data.table(muni_df)
# Remove leading zeros from Municipality code
muni_df$Municipality.code <- as.character(muni_df$`Municipality code`)
muni_df$Municipality.code <- sub("^0+", "", muni_df$Municipality.code)
# Remove rows with missing Municipality code
muni_df <- muni_df[!is.na(Municipality.code) & Municipality.code != ""]
# ================================
# LOAD AND MERGE LAU CODES
# ================================
# --- Load LAU codes ---
lau <- fread(file.path(source_lau_path, "SE_lau.csv"), encoding = "UTF-8")
lau$`LAU NAME NATIONAL` <- iconv(lau$`LAU NAME NATIONAL`, from = "Latin1", to = "UTF-8")
# Ensure LAU codes are character for merging
lau$`LAU CODE` <- as.character(lau$`LAU CODE`)
# Merge municipality data with LAU codes using cleaned codes
merged_muni_lau <- merge(muni_df, lau, by.x = "Municipality.code", by.y = "LAU CODE", all.x = TRUE)
# Keep only the first 6 columns for simplicity
merged_muni_lau <- merged_muni_lau[, 1:6, with = FALSE]
# Add a new column 'type.of.building' with default value "house"
merged_muni_lau[, type.of.building := "house"]
# Rename 'NUTS 3 CODE' to 'nuts3' if it exists
if("NUTS 3 CODE" %in% colnames(merged_muni_lau)) {
setnames(merged_muni_lau, "NUTS 3 CODE", "nuts3")
}
# Convert 'Average price in 1000 SEK' to EUR
exchange_rate <- 0.08745  # 1 SEK ≈ 0.08745 EUR in 2024
merged_muni_lau[, Average.price.EUR := `Average price in 1000 SEK` * 1000 * exchange_rate]
# Create 'nuts2' by taking first 4 characters of 'nuts3'
merged_muni_lau$nuts2 <- substring(merged_muni_lau$nuts3, 1, 4)
# If nuts3 is NA, fallback to nuts2 using Municipality code prefix
merged_muni_lau[, nuts_region := fifelse(!is.na(nuts3), nuts3, substr(Municipality.code, 1, 4))]
# Quick check
head(merged_muni_lau)
# ================================
# PREPARE HPI INDEX FOR MERGING
# ================================
hpi_index <- copy(hpi_df)
# Rename columns to match merge requirements
setnames(hpi_index, c("nuts2", "year", "index_base2024", "nuts3"))
# ================================
# MERGE MUNICIPALITY DATA WITH HPI
# ================================
# Step 1: Merge on nuts3 (preferred, more granular level)
merged_prices <- merge(
merged_muni_lau,
hpi_index[, .(nuts3, nuts2, year, index_base2024)],
by = "nuts3",
all.x = TRUE,
allow.cartesian = TRUE
)
# Step 2: For rows where nuts3 did not match, merge on nuts2 (fallback)
missing_nuts3 <- merged_prices[is.na(index_base2024)]
# Keep only the original municipality columns (excluding nuts3)
original_cols <- setdiff(names(merged_muni_lau), "nuts3")
# Rename duplicate nuts2 columns from the merge for clarity
setnames(missing_nuts3, old = "nuts2.x", new = "nuts2")
setnames(missing_nuts3, old = "nuts2.y", new = "nuts2")
# Keep only the original columns to prepare for second merge
missing_nuts3 <- missing_nuts3[, ..original_cols]
# Merge fallback on nuts2
merge_on_nuts2 <- merge(
missing_nuts3,
hpi_index[, .(nuts2, year, index_base2024)],
by = "nuts2",
all.x = TRUE,
allow.cartesian = TRUE
)
setnames(merge_on_nuts2, "nuts_region", "nuts3")
# Combine all rows into final merged table
merged_prices <- rbind(
merged_prices[!is.na(index_base2024)],  # rows matched on nuts3
merge_on_nuts2,                         # rows matched on nuts2
fill = TRUE
)
# ================================
# CALCULATE HISTORICAL PRICE
# ================================
# Compute back-calculated price based on index_base2024
merged_prices[, price := Average.price.EUR * index_base2024 / 100]
# Columns to remove
cols_to_remove <- c(
"Municipality",
"nuts2.x",
"nuts2.y",
"Municipality code",
"nuts2",
"Average price in 1000 SEK",
"nuts_region",
"Average.price.EUR",
"Number of purchases"
)
# Remove columns
merged_prices <- merged_prices[, (cols_to_remove) := NULL]
# Quick check of final merged data
head(merged_prices)
# #
# # # Filter for municipality 114
# muni_114 <- merged_prices[Municipality.code == "2580" ]
#
# # Plot price over time
# ggplot(muni_114, aes(x = year, y = price)) +
#   geom_line(color = "blue", size = 1) +
#   geom_point(color = "red") +
#   labs(
#     title = "Backcasted Average Price over Time for Municipality 114",
#     x = "Year",
#     y = "Average Price (EUR)"
#   ) +
#   theme_minimal()
# ================================
# AGGREGATION BY NUTS3 AND TYPE
# ================================
# Compute total, average, and count of listings per m2
# separately for houses and flats within each NUTS3 region.
# ================================
dmicro <- read.csv(file.path(output_webscrape_path, "SE_webscraped_clean.csv"), stringsAsFactors = FALSE)
# Clean and transform
price <- read.csv(file.path(output_webscrape_path, "SE_webscraped_clean.csv"), stringsAsFactors = FALSE) %>%
as.data.frame() %>%
mutate(
price_m2 = Winsorize(price_m2, probs = c(0.01, 0.99), na.rm = TRUE),
lau = gsub(".*_", "", LAU_code),
lau = sub("^0+(?=[1-9])", "", lau, perl = TRUE),
indicator = "price_offer",
#price_m2 = price_m2 / 10.2805   # convert to €/ft2 if that’s what you need
) %>%
select(price_m2, lau, NUTS_code, type)
# Convert to data.table
dt <- as.data.table(price)
# Keep valid entries
dt_clean <- dt[!is.na(NUTS_code) & !is.na(price_m2)]
# Summarize by NUTS3 and type
summary_dt <- dt_clean[, .(
total_price_m2 = sum(price_m2, na.rm = TRUE),
avg_price_m2   = mean(price_m2, na.rm = TRUE),
n_ads          = .N
), by = .(lau, NUTS_code, type)]
# Cast each variable
total_price_wide <- dcast(summary_dt, NUTS_code + lau ~ type,
value.var = "total_price_m2",
fun.aggregate = sum, na.rm = TRUE)
setnames(total_price_wide, c("flat", "house"), c("total_flat", "total_house"))
avg_price_wide <- dcast(summary_dt, NUTS_code + lau ~ type,
value.var = "avg_price_m2",
fun.aggregate = mean, na.rm = TRUE)
setnames(avg_price_wide, c("flat", "house"), c("avg_flat", "avg_house"))
n_ads_wide <- dcast(summary_dt, NUTS_code + lau ~ type,
value.var = "n_ads",
fun.aggregate = sum, na.rm = TRUE)
setnames(n_ads_wide, c("flat", "house"), c("n_flat", "n_house"))
# Merge all three
summary_wide <- Reduce(function(x, y) merge(x, y, by = c("NUTS_code", "lau")),
list(total_price_wide, avg_price_wide, n_ads_wide))
#if summary_wide$avg_flat is NaN then you replace avg_flat with the average of the average flat of the corresponding nuts3
# Replace NaN with NA (because mean() handles NA more naturally)
setDT(summary_wide)
summary_wide[is.nan(avg_flat), avg_flat := NA]
# Compute the mean avg_flat for each NUTS3, ignoring missing values
summary_wide[, avg_flat := ifelse(
is.na(avg_flat),
mean(avg_flat, na.rm = TRUE),
avg_flat
), by = NUTS_code]
summary_wide$share_house <- summary_wide$avg_house / summary_wide$avg_flat
# View results
head(summary_wide)
View(summary_wide)
setDT(merged_prices)
setDT(summary_wide)
# Keep only nuts3 and share_house info
shares <- summary_wide[, .(nuts3 = NUTS_code, share_house, lau)]
View(shares)
# ================================
# STEP 2: MERGE SHARES INTO HOUSE DATA
# ================================
# Add the house/flat ratio to each row of merged_prices
merged_prices <- merge(merged_prices, shares, by.x = "Municipality.code", by.y = "lau", all.x = TRUE)
# ================================
# STEP 3: GENERATE FLAT ROWS
# ================================
# ================================
flats <- copy(merged_prices)[type.of.building == "house"]
flats[, type.of.building := "flat"]
flats[, price := price / share_house]
View(flats)
unique(merged_prices$Municipality.code)
unique(shares$lau)
# --- Load CSVs
m2_clean   <- fread(file.path(output_path, "SE_m2_clean.csv"))
m2_mean   <- fread(file.path(output_path, "SE_m2_mean.csv"))
room_clean <- fread(file.path(output_path, "SE_room_clean.csv"))
dwell_tenure_clean <- fread(file.path(output_path, "SE_dwell_tenure.csv"))
dwell_tenure_clean
m2_clean
room_clean <- fread(file.path(output_path, "SE_room_clean.csv"))
room_clean$measure<-"room"
room_clean
# --- Combine all
combined <- rbindlist(
list(
agg_all_levels,
m2_clean,
m2_mean,
room_clean,
dwell_tenure_clean,
dwell_age_clean
),
use.names = TRUE,
fill = TRUE
)
dwell_age_clean <- fread(file.path(output_path, "SE_dwell_age.csv"))
# --- Combine all
combined <- rbindlist(
list(
agg_all_levels,
m2_clean,
m2_mean,
room_clean,
dwell_tenure_clean,
dwell_age_clean
),
use.names = TRUE,
fill = TRUE
)
View(combined)
# Load the CSV files
price <- read.csv(file.path(output_path, "SE_price_m2.csv"), stringsAsFactors = FALSE)
floor <- read.csv(file.path(output_path, "SE_m2_clean.csv"), stringsAsFactors = FALSE)
floor<-data.table(floor)
price<-data.table(price)
# Keep only rows where level == "laucode"
floor <- floor[level == "laucode"]
# Rename column in price to match 'laucode' for merging
setnames(price, old = "Municipality.code", new = "laucode")
setnames(floor, old = "nuts", new = "laucode")
# Make sure the types match
price[, laucode := as.integer(laucode)]
floor[, laucode := as.integer(laucode)]
# Merge price and floor by 'laucode' and 'type.of.building'
merged_data <- merge(price, floor, by = c("laucode", "type.of.building","year"), all.x = TRUE)
# Compute NUTS3 weighted average from LAU, and sum the weights (value)
nuts3_data <- merged_data[, .(
price_m2 = weighted.mean(price_m2, w = value, na.rm = TRUE),
value = sum(value, na.rm = TRUE)   # keep total value for higher-level weighting
), by = .(year, nuts3, type.of.building)]
nuts2_data <- nuts3_data[, .(
price_m2 = round(weighted.mean(price_m2, w = value, na.rm = TRUE), 0),
value = sum(value, na.rm = TRUE)
), by = .(year, nuts2 = substr(nuts3, 1, 4), type.of.building)]
nuts1_data <- nuts3_data[, .(
price_m2 = round(weighted.mean(price_m2, w = value, na.rm = TRUE), 0),
value = sum(value, na.rm = TRUE)
), by = .(year, nuts1 = substr(nuts3, 1, 3), type.of.building)]
nuts0_data <- nuts3_data[, .(
price_m2 = round(weighted.mean(price_m2, w = value, na.rm = TRUE), 0),
value = sum(value, na.rm = TRUE)
), by = .(year, nuts0 = substr(nuts3, 1, 2), type.of.building)]
# Combine all levels into one table
agg_all_levels <- rbindlist(list(
merged_data[, .(year, level = "laucode", code = laucode, type.of.building, price_m2, value)],
nuts3_data[, .(year, level = "nuts3", code = nuts3, type.of.building, price_m2, value)],
nuts2_data[, .(year, level = "nuts2", code = nuts2, type.of.building, price_m2, value)],
nuts1_data[, .(year, level = "nuts1", code = nuts1, type.of.building, price_m2, value)],
nuts0_data[, .(year, level = "nuts0", code = nuts0, type.of.building, price_m2, value)]
), use.names = TRUE)
agg_all_levels$measure<-"price_m2"
setnames(agg_all_levels, old = "code", new = "nuts")
# Copy column
agg_all_levels$value <- agg_all_levels$price_m2
# Remove original column
agg_all_levels$price_m2 <- NULL
agg_all_levels
# --- Load CSVs
m2_clean   <- fread(file.path(output_path, "SE_m2_clean.csv"))
m2_mean   <- fread(file.path(output_path, "SE_m2_mean.csv"))
room_clean <- fread(file.path(output_path, "SE_room_clean.csv"))
room_clean$measure<-"room"
dwell_tenure_clean <- fread(file.path(output_path, "SE_dwell_tenure.csv"))
dwell_age_clean <- fread(file.path(output_path, "SE_dwell_age.csv"))
# --- Combine all
combined <- rbindlist(
list(
agg_all_levels,
m2_clean,
m2_mean,
room_clean,
dwell_tenure_clean,
dwell_age_clean
),
use.names = TRUE,
fill = TRUE
)
combined
View(combined)
unique(combined[is.na(value)]$nuts)
unique(combined[!is.na(value)]$nuts)
unique(combined[!is.na(value) & measure=price_m2]$nuts)
unique(combined[!is.na(value) & measure=="price_m2"]$nuts)
unique(combined[is.na(value) & measure=="price_m2"]$nuts)
unique(combined[is.na(value) & measure=="dwell__1930"]$nuts)
unique(combined$measure)
unique(combined[is.na(value) & measure=="total_m2"]$nuts)
unique(combined[is.na(value) & measure=="dwell_rented"]$nuts)
#---------------------------------------------------------
# SLovenia Main
# This script calls all Sweden housing data scripts and runs them in order.
#---------------------------------------------------------
rm(list=ls())
cc <- "SI"
# Base paths
base_path <- "C:/Users/annai/Documents/backup_computer_ec/Contratti_lavoro/EU_Temporary_agent/materiali_di_lavoro/mapadomo/mapadomo_ari"
# Paths using the 'cc' variable
rcode_path <- file.path(base_path, cc, "rcode")
source_stock_path <- file.path(base_path, cc, "sourcedata", "stocks")
source_prices_path <- file.path(base_path, cc, "sourcedata", "prices")
source_lau_path <- file.path(base_path, cc, "sourcedata", "laucodes")
output_path <- file.path(base_path, cc, "outputdata", "temp")
output_end_path <- file.path(base_path, cc, "outputdata", "final")
source_income_path <- file.path(base_path, cc, "sourcedata", "income")
run_script <- function(script_path) {
cat("▶ Running:", script_path, "\n")
source(script_path, encoding = "UTF-8")
cat("✔ Finished:", script_path, "\n\n")
}
# --- Load dwelling data ---
stock <- fread(file.path(output_path, "SE_m2_clean.csv"), encoding = "UTF-8")
# Aggregate flat and house values
stock_lau <- stock[, .(value = sum(value), nuts = head(nuts3, 1)), by = .(laucode, type, indicator, year)]
# Filter for the years of interest
my_years <- c("2011", "2015", "2018", "2021")
stock_lau <- stock_lau[year %in% my_years]
# Compute total values for type == "all" for each LAU + indicator + year
totals <- stock_lau[type == "all", .(total_value = value), by = .(laucode, indicator, year)]
# Merge totals back to stock_lau
stock_lau_share <- merge(
stock_lau,
totals,
by = c("laucode", "indicator", "year"),
all.x = TRUE
)
# Calculate share
stock_lau_share[, share := fifelse(is.na(total_value) | total_value == 0, 0, value / total_value)]
# Optional: drop total_value if you don’t need it
stock_lau_share[, total_value := NULL]
##################### new building ############################################################
build_new <- fread(file.path(source_stock_path, "SI_new_built_2022.csv"), encoding = "UTF-8")
stock <- fread(file.path(output_path, "SE_m2_clean.csv"), encoding = "UTF-8")
View(stock)
#---------------------------------------------------------
# SWEDEN Main
# This script calls all Sweden housing data scripts and runs them in order.
#---------------------------------------------------------
rm(list=ls())
cc <- "SE"
# Base paths
base_path <- "C:/Users/annai/Documents/backup_computer_ec/Contratti_lavoro/EU_Temporary_agent/materiali_di_lavoro/mapadomo/mapadomo_ari"
# Paths using the 'cc' variable
rcode_path <- file.path(base_path, cc, "rcode")
source_stock_path <- file.path(base_path, cc, "sourcedata", "stocks")
source_prices_path <- file.path(base_path, cc, "sourcedata", "prices")
source_lau_path <- file.path(base_path, cc, "sourcedata", "laucodes")
output_path <- file.path(base_path, cc, "outputdata", "temp")
output_webscrape_path <- file.path(base_path, cc, "outputdata", "webscraped")
output_end_path <- file.path(base_path, cc, "outputdata", "final")
source_income_path <- file.path(base_path, cc, "sourcedata", "income")
run_script <- function(script_path) {
cat("▶ Running:", script_path, "\n")
source(script_path, encoding = "UTF-8")
cat("✔ Finished:", script_path, "\n\n")
}
# --- Call all sub-scripts for stock timeseries creation (add as needed) ---
run_script(file.path(rcode_path, "stocks", paste0(cc, "_dwelling_13_24.R")))
